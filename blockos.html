<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockOS Terminal</title>
    <style>
        /* 保持严格的命令行风格 */
        body {
            font-family: "Courier New", Courier, monospace;
            background-color: #000;
            color: #00ff00;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 防止页面整体滚动 */
        }
        .terminal {
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto; /* 垂直滚动 */
            overflow-x: auto; /* 水平滚动，防止内容溢出 */
        }
        .output {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .input {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #111;
            border-top: 1px solid #333;
            width: 100%;
            box-sizing: border-box;
        }
        input[type="text"] {
            background: transparent;
            border: none;
            color: #00ff00;
            outline: none;
            width: calc(100% - 40px);
            font-family: "Courier New", Courier, monospace;
        }
        /* 文本颜色类 - 保持简单 */
        .error { color: #ff4d4d; }
        .warn { color: #ffcc00; }
        .log { color: #00ff00; }
        .success { color: #00ffff; }
        .info { color: #ffff00; }
        .path { color: #ff8000; margin-right: 5px; }
        
        /* 进度条使用纯文本字符表示 */
        .progress-bar {
            display: inline-block;
            vertical-align: middle;
        }


        /* 下载任务列表样式优化 */
        .download-task-display {
            white-space: pre;
        }

        /* 滚动条样式美化 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #111;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #333;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <!-- 分离内容区域和输入区域 -->
    <div class="terminal">
        <div class="output" id="output"></div>
    </div>
    <!-- 输入区固定在底部 -->
    <div class="input">
        <span class="path" id="currentPath">/disk/</span>
        <input type="text" id="commandInput" placeholder="Enter command..." autocomplete="off">
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        const outputDiv = document.getElementById('output');
        const commandInput = document.getElementById('commandInput');
        const currentPathElement = document.getElementById('currentPath');
        const terminalDiv = document.querySelector('.terminal'); // 获取终端容器


        // 重定向控制台输出 - 严格使用文本
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;


        console.log = function(...args) {
            const output = args.join(' ');
            const p = document.createElement('p');
            p.className = 'log';
            p.textContent = output; // 始终使用textContent
            outputDiv.appendChild(p);
            scrollToBottom();
            originalConsoleLog(...args);
        };


        console.error = function(...args) {
            const output = args.join(' ');
            const p = document.createElement('p');
            p.className = 'error';
            p.textContent = output;
            outputDiv.appendChild(p);
            scrollToBottom();
            originalConsoleError(...args);
        };


        console.warn = function(...args) {
            const output = args.join(' ');
            const p = document.createElement('p');
            p.className = 'warn';
            p.textContent = output;
            outputDiv.appendChild(p);
            scrollToBottom();
            originalConsoleWarn(...args);
        };


        // 自定义日志方法
        function infoLog(...args) {
            const output = args.join(' ');
            const p = document.createElement('p');
            p.className = 'info';
            p.textContent = output;
            outputDiv.appendChild(p);
            scrollToBottom();
        }


        // 自定义tree输出方法，保留空格格式
        function treeLog(text) {
            const p = document.createElement('p');
            p.className = 'log';
            p.textContent = text;
            outputDiv.appendChild(p);
            scrollToBottom();
        }


        // 生成指定长度的字符串
        function repeatChar(char, length) {
            return new Array(length + 1).join(char);
        }


        // 命令管理系统 - 新增功能
        const CommandManager = {
            // 系统命令列表 - 不可修改
            systemCommands: [
                'ls', 'tree', 'lsd', 'cd', 'mkdir', 'touch', 'rm', 'cat', 
                'ld', 'mount', 'unmount', 'ipj', 'ife', 'odk', 'run', 'js',
                'dd', 'dlist', 'dstop', 'dstart', 'drm', 'dlsc', 'mv', 'cp',
                'clear', 'help', 'registercmd', 'unregistercmd', 'listcmds'
            ],
            
            // 存储自定义命令
            customCommands: {},
            
            /**
             * 注册自定义命令
             * @param {string} name - 命令名称
             * @param {function} handler - 命令处理函数，接收args参数
             * @param {string} description - 命令描述，用于help
             * @returns {boolean} - 是否注册成功
             */
            register: function(name, handler, description = '') {
                // 检查是否为系统命令
                if (this.systemCommands.includes(name.toLowerCase())) {
                    console.error(`无法注册命令 '${name}': 系统命令不可覆盖`);
                    return false;
                }
                
                // 检查命令名是否有效
                if (!/^[a-zA-Z0-9_-]+$/.test(name)) {
                    console.error(`命令名 '${name}' 无效，只能包含字母、数字、下划线和连字符`);
                    return false;
                }
                
                // 检查处理函数是否有效
                if (typeof handler !== 'function') {
                    console.error(`注册命令 '${name}' 失败: 处理函数必须是一个函数`);
                    return false;
                }
                
                this.customCommands[name.toLowerCase()] = {
                    handler: handler,
                    description: description
                };
                
                console.log(`命令 '${name}' 已成功注册`);
                return true;
            },
            
            /**
             * 注销自定义命令
             * @param {string} name - 命令名称
             * @returns {boolean} - 是否注销成功
             */
            unregister: function(name) {
                const cmdName = name.toLowerCase();
                
                // 检查是否为系统命令
                if (this.systemCommands.includes(cmdName)) {
                    console.error(`无法注销命令 '${name}': 系统命令不可注销`);
                    return false;
                }
                
                // 检查命令是否存在
                if (!this.customCommands[cmdName]) {
                    console.error(`无法注销命令 '${name}': 命令不存在`);
                    return false;
                }
                
                delete this.customCommands[cmdName];
                console.log(`命令 '${name}' 已成功注销`);
                return true;
            },
            
            /**
             * 执行命令
             * @param {string} name - 命令名称
             * @param {array} args - 命令参数
             * @returns {boolean} - 是否执行成功
             */
            execute: function(name, args) {
                const cmdName = name.toLowerCase();
                
                // 先检查自定义命令
                if (this.customCommands[cmdName]) {
                    try {
                        this.customCommands[cmdName].handler(args);
                        return true;
                    } catch (error) {
                        console.error(`执行命令 '${name}' 时出错: ${error.message}`);
                        return false;
                    }
                }
                
                // 系统命令由主执行器处理
                return false;
            },
            
            /**
             * 列出所有命令
             * @param {boolean} showSystem - 是否显示系统命令
             * @param {boolean} showCustom - 是否显示自定义命令
             */
            list: function(showSystem = true, showCustom = true) {
                if (showSystem) {
                    console.log("系统命令:");
                    this.systemCommands.sort().forEach(cmd => {
                        console.log(`  ${cmd}`);
                    });
                }
                
                if (showCustom) {
                    const customCmds = Object.keys(this.customCommands);
                    if (customCmds.length > 0) {
                        console.log("\n自定义命令:");
                        customCmds.sort().forEach(cmd => {
                            const desc = this.customCommands[cmd].description 
                                ? ` - ${this.customCommands[cmd].description}` 
                                : '';
                            console.log(`  ${cmd}${desc}`);
                        });
                    } else if (!showSystem) {
                        console.log("没有注册的自定义命令");
                    }
                }
            }
        };


        // 多磁盘系统
        let disks = {
            'disk': {
                name: 'disk',
                filesystem: {
                    name: '/',
                    type: 'directory',
                    children: {
                        'data': { 
                            name: 'data', 
                            type: 'directory', 
                            children: {
                                'logs': { 
                                    name: 'logs', 
                                    type: 'directory', 
                                    children: {
                                        'system.log': { name: 'system.log', type: 'file', content: 'System logs...' }
                                    } 
                                },
                                'config.json': { name: 'config.json', type: 'file', content: '{"version": "1.0"}' }
                            }
                        },
                        'programs': { 
                            name: 'programs', 
                            type: 'directory', 
                            children: {
                                'app1': { 
                                    name: 'app1', 
                                    type: 'directory', 
                                    children: {
                                        'main.js': {
                                            name: 'main.js', 
                                            type: 'file', 
                                            content: 'console.log("App1 main program started");\nfunction run() {\n  return "App1 running";\n}'
                                        },
                                        'start.r': {
                                            name: 'start.r', 
                                            type: 'file', 
                                            content: 'print("Starting App1...")\nload("main.js")'
                                        }
                                    } 
                                },
                                'core.js': {
                                    name: 'core.js', 
                                    type: 'file', 
                                    content: 'console.log("Core system initialized");\nexport function init() {\n  return true;\n}'
                                }
                            } 
                        },
                        'downloads': {  // 下载目录
                            name: 'downloads', 
                            type: 'directory', 
                            children: {}
                        },
                        'readme.txt': { name: 'readme.txt', type: 'file', content: 'Welcome to BlockOS!\n- .js 为程序文件\n- .r 为脚本文件' }
                    }
                }
            }
        };
        
        // 下载任务管理
        let downloadTasks = [];
        let nextTaskId = 1;
        
        // 当前状态
        let currentDisk = 'disk';
        let currentPath = ['/'];


        // 辅助函数：滚动到底部
        function scrollToBottom() {
            // 使用终端容器进行滚动，而不是输出div
            terminalDiv.scrollTop = terminalDiv.scrollHeight;
        }


        // 更新当前路径显示
        function updateCurrentPath() {
            currentPathElement.textContent = `/${currentDisk}${currentPath.join('/').replace('//', '/')} `;
        }


        // 获取指定路径的节点 - 修复根目录文件访问问题
        function getNodeByPath(path) {
            const resolved = resolvePath(path);
            
            // 处理根目录
            if (resolved.isRoot) {
                return { isRoot: true };
            }
            
            // 处理跨磁盘路径
            if (resolved.isCrossDisk) {
                const targetDisk = disks[resolved.diskName];
                if (!targetDisk) return null;
                
                let dir = targetDisk.filesystem;
                for (const part of resolved.subPath) {
                    if (!dir.children[part]) {
                        return null;
                    }
                    dir = dir.children[part];
                }
                return { node: dir, disk: targetDisk };
            }
            
            // 处理当前磁盘内路径 - 修复根目录文件访问
            let dir = disks[currentDisk].filesystem;
            for (let i = 1; i < resolved.path.length; i++) {
                // 修复：检查是否存在该子节点
                if (!dir.children || !dir.children[resolved.path[i]]) {
                    return null;
                }
                dir = dir.children[resolved.path[i]];
            }
            return { node: dir, disk: disks[currentDisk] };
        }


        // 解析路径
        function resolvePath(path) {
            let resolvedPath = [...currentPath];
            
            if (path.startsWith('/')) {
                // 绝对路径处理
                if (path === '/') {
                    return { isRoot: true };
                }
                
                const pathParts = path.split('/').filter(part => part !== '');
                // 检查是否是跨磁盘路径
                if (pathParts.length > 0 && disks[pathParts[0]]) {
                    return { 
                        isCrossDisk: true, 
                        diskName: pathParts[0], 
                        subPath: pathParts.slice(1)
                    };
                } else {
                    // 当前磁盘内的绝对路径
                    resolvedPath = ['/'];
                }
            }
            
            // 处理路径部分
            const pathParts = path.startsWith('/') ? 
                path.split('/').filter(part => part !== '') : 
                path.split('/').filter(part => part !== '');
                
            pathParts.forEach(part => {
                if (part === '.') return;
                if (part === '..' && resolvedPath.length > 1) {
                    resolvedPath.pop();
                } else if (part !== '..') {
                    resolvedPath.push(part);
                }
            });
            
            return { isRoot: false, isCrossDisk: false, path: resolvedPath };
        }


        // 切换磁盘
        function switchDisk(diskName) {
            if (!disks[diskName]) {
                console.error(`磁盘 ${diskName} 不存在`);
                return false;
            }
            
            currentDisk = diskName;
            currentPath = ['/'];
            updateCurrentPath();
            console.log(`已切换到磁盘 ${diskName}`);
            return true;
        }


        // ls 命令实现
        function ls(path = '.') {
            const nodeInfo = getNodeByPath(path);
            
            if (!nodeInfo) {
                console.error(`路径 ${path} 不存在于当前挂载的磁盘中`);
                return false;
            }
            
            // 处理根目录（显示所有磁盘）
            if (nodeInfo.isRoot) {
                console.log("已挂载的磁盘:");
                Object.keys(disks).forEach(diskName => {
                    console.log(`${diskName}${diskName === currentDisk ? ' *' : ''}`);
                });
                console.log("* 表示当前挂载的磁盘");
                return true;
            }
            
            const { node, disk } = nodeInfo;
            
            // 显示路径信息
            console.log(`路径 ${path} (${disk.name}) 内容:`);
            
            // 如果是文件，直接显示文件名
            if (node.type === 'file') {
                console.log(node.name);
                return true;
            }
            
            // 如果是目录，显示其内容
            const entries = Object.values(node.children);
            if (entries.length === 0) {
                console.log("目录为空");
                return true;
            }
            
            // 区分显示目录、程序和脚本
            entries.forEach(entry => {
                if (entry.type === 'directory') {
                    console.log(`${entry.name}/`);
                } else {
                    console.log(entry.name);
                }
            });
            
            return true;
        }


        // tree 命令实现
        function tree(path = '.') {
            // tree 和 tree . 都显示整个磁盘的树形结构
            if (path === '.' || path === '/') {
                return displayDiskTree(currentDisk);
            }
            
            // 解析路径
            const nodeInfo = getNodeByPath(path);
            
            if (!nodeInfo) {
                console.error(`路径 ${path} 不存在于当前挂载的磁盘中`);
                return false;
            }
            
            // 处理根目录（显示当前磁盘树形结构）
            if (nodeInfo.isRoot) {
                return displayDiskTree(currentDisk);
            }
            
            const { node, disk } = nodeInfo;
            
            // 如果是文件，直接显示
            if (node.type === 'file') {
                console.log(node.name);
                return true;
            }
            
            // 显示指定目录的树形结构
            console.log(`当前磁盘 ${disk.name} 中路径 ${path} 的树形结构:`);
            treeLog(`${node.name}/`);
            displayTreeRecursive(node.children, '');
            
            return true;
        }


        // 显示整个磁盘的树形结构
        function displayDiskTree(diskName) {
            const disk = disks[diskName];
            if (!disk) {
                console.error(`磁盘 ${diskName} 不存在`);
                return false;
            }
            
            console.log(`磁盘 ${diskName} 的完整树形结构:`);
            treeLog(`/${diskName}/`);
            displayTreeRecursive(disk.filesystem.children, '');
            
            return true;
        }


        // 递归显示树形结构
        function displayTreeRecursive(children, prefix) {
            const entries = Object.values(children).sort((a, b) => {
                // 先显示目录，再显示文件
                if (a.type !== b.type) {
                    return a.type === 'directory' ? -1 : 1;
                }
                // 按名称排序
                return a.name.localeCompare(b.name);
            });
            
            entries.forEach((entry, index) => {
                const isLast = index === entries.length - 1;
                const linePrefix = isLast ? '└── ' : '├── ';
                const childPrefix = isLast ? '    ' : '│   ';
                
                if (entry.type === 'directory') {
                    treeLog(`${prefix}${linePrefix}${entry.name}/`);
                    // 递归显示子目录
                    if (Object.keys(entry.children).length > 0) {
                        displayTreeRecursive(entry.children, prefix + childPrefix);
                    }
                } else {
                    treeLog(`${prefix}${linePrefix}${entry.name}`);
                }
            });
        }


        // 查看所有挂载的磁盘
        function lsd() {
            return ls('/');
        }


        // 切换目录命令
        function cd(path = '/') {
            const nodeInfo = getNodeByPath(path);
            
            if (!nodeInfo || nodeInfo.isRoot) {
                // 处理根目录
                currentPath = ['/'];
                updateCurrentPath();
                console.log(`已切换到 ${currentDisk} 磁盘根目录`);
                return true;
            }
            
            const { node } = nodeInfo;
            
            if (!node || node.type !== 'directory') {
                console.error(`目录 ${path} 不存在`);
                return false;
            }


            // 更新当前路径
            const resolved = resolvePath(path);
            if (!resolved.isCrossDisk) {
                currentPath = resolved.path;
                updateCurrentPath();
                console.log(`已切换到 ${currentPath.join('/').replace('//', '/')}`);
                return true;
            } else {
                console.error("cd命令不支持跨磁盘切换，请使用ld命令");
                return false;
            }
        }


        // 创建目录
        function mkdir(directoryName) {
            const currentDirInfo = getNodeByPath('.');
            if (!currentDirInfo || currentDirInfo.isRoot || currentDirInfo.node.type !== 'directory') {
                console.error("当前目录不存在");
                return false;
            }


            const currentDir = currentDirInfo.node;
            
            if (currentDir.children[directoryName]) {
                console.error(`目录 ${directoryName} 已存在`);
                return false;
            }


            currentDir.children[directoryName] = {
                name: directoryName,
                type: 'directory',
                children: {}
            };


            console.log(`目录 ${directoryName} 创建成功`);
            return true;
        }


        // 创建文件
        function touch(filename) {
            const currentDirInfo = getNodeByPath('.');
            if (!currentDirInfo || currentDirInfo.isRoot || currentDirInfo.node.type !== 'directory') {
                console.error("当前目录不存在");
                return false;
            }


            const currentDir = currentDirInfo.node;
            
            if (currentDir.children[filename]) {
                console.error(`文件 ${filename} 已存在`);
                return false;
            }


            currentDir.children[filename] = {
                name: filename,
                type: 'file',
                content: ''
            };


            console.log(`文件 ${filename} 创建成功`);
            return true;
        }


        // 删除文件/目录
        function rm(path) {
            const resolved = resolvePath(path);
            
            if (resolved.isRoot) {
                console.error("不能删除根目录");
                return false;
            }
            
            if (resolved.isCrossDisk) {
                console.error("rm命令不支持跨磁盘操作");
                return false;
            }
            
            // 获取父目录 - 修复：处理根目录情况
            const parentPath = resolved.path.length > 1 
                ? resolved.path.slice(0, -1).join('/') 
                : '/';  // 如果是根目录下的文件/目录，父路径为根目录
            
            const parentInfo = getNodeByPath(parentPath);
            
            if (!parentInfo || parentInfo.isRoot) {
                // 父目录是根目录的情况
                if (resolved.path.length !== 2) {  // 根目录下的项目路径长度应为2: ['/', 'item']
                    console.error(`路径 ${path} 不存在`);
                    return false;
                }
                
                // 父目录是当前磁盘的根目录
                const targetName = resolved.path[1];
                if (!disks[currentDisk].filesystem.children[targetName]) {
                    console.error(`路径 ${path} 不存在`);
                    return false;
                }
                
                // 从根目录删除
                delete disks[currentDisk].filesystem.children[targetName];
                console.log(`已删除 ${path}`);
                return true;
            }
            
            // 常规情况 - 父目录是普通目录
            if (parentInfo.node.type !== 'directory') {
                console.error(`路径 ${path} 不存在`);
                return false;
            }
            
            const targetName = resolved.path[resolved.path.length - 1];
            if (!parentInfo.node.children[targetName]) {
                console.error(`路径 ${path} 不存在`);
                return false;
            }


            delete parentInfo.node.children[targetName];
            console.log(`已删除 ${path}`);
            return true;
        }


        // 查看文件内容 - 纯文本显示，不添加任何样式
        function cat(filename) {
            const fileInfo = getNodeByPath(filename);
            
            if (!fileInfo || fileInfo.isRoot || fileInfo.node.type !== 'file') {
                console.error(`文件 ${filename} 不存在`);
                return null;
            }


            // 纯文本显示文件内容，保持命令行风格
            console.log(`===== 文件 ${filename} 内容开始 =====`);
            const lines = fileInfo.node.content.split('\n');
            lines.forEach(line => console.log(line)); // 每行单独输出
            console.log(`===== 文件 ${filename} 内容结束 =====`);
            
            return fileInfo.node.content;
        }


        // 导入文件夹 - ipj 命令
        function importFolder() {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = false;
            
            input.onchange = async function(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                const currentDir = getNodeByPath('.');
                if (!currentDir || currentDir.isRoot || currentDir.node.type !== 'directory') {
                    console.error("当前目录不存在");
                    return;
                }
                
                // 获取基础文件夹名称
                const baseFolderName = files[0].webkitRelativePath.split('/')[0];
                
                // 创建基础文件夹
                if (!currentDir.node.children[baseFolderName]) {
                    currentDir.node.children[baseFolderName] = {
                        name: baseFolderName,
                        type: 'directory',
                        children: {}
                    };
                    console.log(`创建目录: ${baseFolderName}`);
                }
                
                const baseDir = currentDir.node.children[baseFolderName];
                
                // 处理所有文件
                for (const file of files) {
                    try {
                        const relativePath = file.webkitRelativePath;
                        const pathParts = relativePath.split('/').slice(1); // 移除基础文件夹
                        const fileName = pathParts.pop();
                        
                        // 创建中间目录
                        let currentTargetDir = baseDir;
                        for (const dirPart of pathParts) {
                            if (!currentTargetDir.children[dirPart]) {
                                currentTargetDir.children[dirPart] = {
                                    name: dirPart,
                                    type: 'directory',
                                    children: {}
                                };
                                console.log(`创建目录: ${dirPart}`);
                            }
                            currentTargetDir = currentTargetDir.children[dirPart];
                        }
                        
                        // 检查文件是否已存在
                        if (currentTargetDir.children[fileName]) {
                            console.warn(`文件 ${fileName} 已存在，已跳过`);
                            continue;
                        }
                        
                        // 读取文件内容
                        const content = await file.text();
                        
                        // 创建文件
                        currentTargetDir.children[fileName] = {
                            name: fileName,
                            type: 'file',
                            content: content
                        };
                        
                        console.log(`导入文件: ${relativePath}`);
                    } catch (error) {
                        console.error(`导入文件 ${file.name} 失败: ${error.message}`);
                    }
                }
                
                console.log(`文件夹 ${baseFolderName} 导入完成`);
            };
            
            input.click();
        }


        // 导入文件 - ife 命令
        function importFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            
            input.onchange = async function(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                const currentDir = getNodeByPath('.');
                if (!currentDir || currentDir.isRoot || currentDir.node.type !== 'directory') {
                    console.error("当前目录不存在");
                    return;
                }
                
                // 处理每个文件
                for (const file of files) {
                    try {
                        const fileName = file.name;
                        
                        // 检查文件是否已存在
                        if (currentDir.node.children[fileName]) {
                            console.warn(`文件 ${fileName} 已存在，已跳过`);
                            continue;
                        }
                        
                        // 读取文件内容
                        const content = await file.text();
                        
                        // 创建文件
                        currentDir.node.children[fileName] = {
                            name: fileName,
                            type: 'file',
                            content: content
                        };
                        
                        console.log(`导入文件: ${fileName}`);
                    } catch (error) {
                        console.error(`导入文件 ${file.name} 失败: ${error.message}`);
                    }
                }
                
                console.log("文件导入完成");
            };
            
            input.click();
        }


        // 导出磁盘为.dk - odk 命令
        async function exportAsDk(filename = null) {
            // 生成默认文件名: disk:时间戳(精确到秒).dk
            if (!filename) {
                const timestamp = Math.floor(Date.now() / 1000);
                filename = `disk:${timestamp}.dk`;
            } else if (!filename.endsWith('.dk')) {
                filename += '.dk';
            }


            try {
                const zip = new JSZip();
                zip.file('filesystem.json', JSON.stringify(disks[currentDisk].filesystem));
                
                const content = await zip.generateAsync({ type: "blob" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(content);
                a.download = filename;
                a.click();
                
                console.log(`磁盘 ${currentDisk} 已导出为 ${filename}`);
                return true;
            } catch (error) {
                console.error(`导出失败: ${error.message}`);
                return false;
            }
        }


        // 运行程序或脚本 - 修复根目录文件运行问题和JavaScript执行问题
        function run(path) {
            // 修复：支持根目录文件运行，处理绝对路径
            let resolvedPath = path;
            if (!path.startsWith('/')) {
                // 如果是相对路径，尝试从当前目录和根目录都查找
                const rootPath = `/${path}`;
                const rootFileInfo = getNodeByPath(rootPath);
                if (rootFileInfo && !rootFileInfo.isRoot && rootFileInfo.node.type === 'file') {
                    resolvedPath = rootPath;
                }
            }
            
            const fileInfo = getNodeByPath(resolvedPath);
            
            if (!fileInfo || fileInfo.isRoot || fileInfo.node.type !== 'file') {
                console.error(`文件 ${path} 不存在`);
                return false;
            }
            
            const fileName = fileInfo.node.name;
            
            try {
                const content = fileInfo.node.content;
                
                // 创建执行环境
                const executionContext = {
                    console: console,
                    import: function(modulePath) {
                        // 实现简单的导入功能
                        const imported = getNodeByPath(modulePath);
                        if (!imported || imported.isRoot || imported.node.type !== 'file') {
                            throw new Error(`无法导入 ${modulePath}: 文件不存在`);
                        }
                        
                        // 执行导入的文件并返回其导出对象
                        const moduleContent = imported.node.content;
                        const moduleExports = {};
                        const moduleFunction = new Function('exports', 'console', 'CommandManager', moduleContent);
                        moduleFunction(moduleExports, console, CommandManager);
                        return moduleExports;
                    },
                    CommandManager: CommandManager // 暴露命令管理器
                };
                
                // 根据文件类型执行
                if (fileName.endsWith('.js')) {
                    // 执行JavaScript程序 - 修复：简化参数绑定
                    // 只绑定console参数，避免未使用import时的错误
                    const programFunction = new Function('console', 'CommandManager', content);
                    programFunction(console, CommandManager);
                } else if (fileName.endsWith('.r')) {
                    // 执行r脚本
                    // 简单的r语法转换为JavaScript
                    const jsCode = content
                        .replace(/print\((.*?)\)/g, 'console.log($1)')
                        .replace(/load\((.*?)\)/g, 'const module = import($1)');
                    
                    const scriptFunction = new Function('console', 'import', 'CommandManager', jsCode);
                    scriptFunction(console, executionContext.import, CommandManager);
                } else {
                    console.error("仅支持运行 .js 程序和 .r 脚本");
                    return false;
                }
                
            } catch (error) {
                console.error(`运行 ${fileName} 失败: ${error.message}`);
            }
            
            return true;
        }


        // 新增：直接执行JavaScript代码的命令
        function executeJavaScript(code) {
            try {
                // 创建一个安全的执行环境，包含CommandManager
                const result = new Function('console', 'CommandManager', 'return ' + code)(console, CommandManager);
                if (result !== undefined) {
                    console.log("结果:", result);
                }
            } catch (error) {
                console.error("JavaScript执行错误:", error.message);
            }
        }


        // 下载命令 - dd url [path] - 支持真实下载
        function dd(url, savePath = null) {
            // 解析文件名
            let fileName = url.split('/').pop().split('?')[0];
            if (!fileName) {
                fileName = `download_${Date.now()}`;
            }
            
            // 默认保存到downloads目录
            if (!savePath) {
                savePath = `downloads/${fileName}`;
            }
            
            // 检查保存目录是否存在
            const savePathParts = savePath.split('/');
            const fileNamePart = savePathParts.pop();
            const dirPath = savePathParts.join('/') || '.';
            
            const dirInfo = getNodeByPath(dirPath);
            if (!dirInfo || dirInfo.isRoot || dirInfo.node.type !== 'directory') {
                console.error(`保存目录 ${dirPath} 不存在`);
                return false;
            }
            
            // 检查文件是否已存在
            if (dirInfo.node.children[fileNamePart]) {
                console.warn(`文件 ${fileNamePart} 已存在，将覆盖`);
            }
            
            // 创建下载任务
            const taskId = nextTaskId++;
            const task = {
                id: taskId,
                url: url,
                fileName: fileNamePart,
                savePath: savePath,
                status: 'downloading', // downloading, paused, complete, failed
                progress: 0,
                totalSize: 0,
                downloadedSize: 0,
                startTime: new Date(),
                xhr: null,
                interval: null
            };
            
            downloadTasks.push(task);
            
            // 创建真实的下载请求
            const xhr = new XMLHttpRequest();
            task.xhr = xhr;
            
            xhr.open('GET', url, true);
            xhr.responseType = 'blob';
            
            // 监听进度事件
            xhr.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    task.totalSize = e.total;
                    task.downloadedSize = e.loaded;
                    task.progress = (e.loaded / e.total) * 100;
                    updateDownloadDisplay();
                }
            });
            
            // 监听请求完成
            xhr.addEventListener('load', function() {
                if (xhr.status === 200) {
                    task.progress = 100;
                    task.downloadedSize = task.totalSize;
                    task.status = 'complete';
                    
                    // 读取下载的内容
                    const reader = new FileReader();
                    reader.onload = function() {
                        // 将内容保存到文件系统
                        dirInfo.node.children[fileNamePart] = {
                            name: fileNamePart,
                            type: 'file',
                            content: reader.result, // 保存文件内容
                            size: task.totalSize,
                            downloaded: true
                        };
                        
                        infoLog(`下载完成: ${task.fileName} (${formatFileSize(task.totalSize)})`);
                    };
                    reader.readAsText(xhr.response); // 以文本形式读取所有文件
                } else {
                    task.status = 'failed';
                    console.error(`下载失败: 服务器返回状态码 ${xhr.status}`);
                }
                
                clearInterval(task.interval);
                updateDownloadDisplay();
            });
            
            // 监听错误
            xhr.addEventListener('error', function() {
                task.status = 'failed';
                clearInterval(task.interval);
                console.error(`下载失败: 网络错误`);
                updateDownloadDisplay();
            });
            
            // 监听abort
            xhr.addEventListener('abort', function() {
                task.status = 'paused';
                clearInterval(task.interval);
                console.log(`下载已暂停: ${task.fileName}`);
                updateDownloadDisplay();
            });
            
            // 开始下载
            xhr.send();
            
            // 启动进度更新计时器（处理不可计算长度的情况）
            task.interval = setInterval(() => {
                if (task.status !== 'downloading') return;
                
                // 如果无法计算总长度，模拟进度增加
                if (task.totalSize === 0) {
                    task.downloadedSize += 1024 * 10; // 每次增加10KB
                    task.progress = Math.min(task.progress + 0.5, 99); // 最多到99%
                    updateDownloadDisplay();
                }
            }, 500);
            
            console.log(`开始下载 [${taskId}]: ${url}`);
            console.log(`保存路径: ${savePath}`);
            return true;
        }


        // 更新下载任务显示 - 使用纯文本进度条
        function updateDownloadDisplay() {
            // 找到所有下载列表元素并更新
            const downloadDisplays = outputDiv.querySelectorAll('.download-task-display');
            if (downloadDisplays.length > 0) {
                // 移除旧显示
                downloadDisplays.forEach(display => {
                    display.parentNode.removeChild(display);
                });
            }
            
            // 如果有任务，重新显示
            if (downloadTasks.length > 0) {
                dlist();
            }
        }


        // 显示下载列表 - dlist
        function dlist() {
            if (downloadTasks.length === 0) {
                console.log("没有下载任务");
                return true;
            }
            
            // 创建下载列表容器
            const container = document.createElement('div');
            container.className = 'download-task-display log';
            
            // 添加标题
            const title = document.createElement('p');
            title.textContent = "下载任务列表:";
            container.appendChild(title);
            
            // 计算列宽，确保百分比单独一栏且自适应，增加列间距
            const columnSpacing = 4; // 列之间的空格数
            const maxIdLength = Math.max(...downloadTasks.map(t => t.id.toString().length), 2);
            const statusWidth = 10; // 状态列宽度增加
            const progressBarWidth = 20; // 进度条固定20个字符
            const percentWidth = 8; // 百分比列宽度增加
            const sizeWidth = 18; // 大小列宽度增加
            
            // 显示列标题，添加额外空格增加间距
            const header = document.createElement('p');
            header.textContent = `ID${' '.repeat(maxIdLength - 2 + columnSpacing)}状态${' '.repeat(statusWidth - 2 + columnSpacing)}进度${' '.repeat(progressBarWidth - 2 + columnSpacing)}百分比${' '.repeat(percentWidth - 2 + columnSpacing)}大小${' '.repeat(sizeWidth - 2 + columnSpacing)}文件名`;
            container.appendChild(header);
            
            // 显示每个任务
            downloadTasks.forEach(task => {
                let status = task.status.padEnd(statusWidth); // 固定宽度
                
                // 文本进度条
                const barLength = progressBarWidth;
                const filledLength = Math.round((task.progress / 100) * barLength);
                const emptyLength = barLength - filledLength;
                const progressBar = repeatChar('█', filledLength) + repeatChar('-', emptyLength);
                
                // 百分比 - 单独一栏
                const percent = `${task.progress.toFixed(1)}%`.padEnd(percentWidth);
                
                // 格式化大小
                const sizeStr = task.totalSize > 0 
                    ? `${formatFileSize(task.downloadedSize)}/${formatFileSize(task.totalSize)}`
                    : `${formatFileSize(task.downloadedSize)}`;
                const sizeStrPadded = sizeStr.padEnd(sizeWidth);
                
                // 任务ID
                const idStr = task.id.toString().padEnd(maxIdLength);
                
                // 任务行，添加额外空格增加列间距
                const taskLine = document.createElement('p');
                taskLine.textContent = `${idStr}${' '.repeat(columnSpacing)}${status}${' '.repeat(columnSpacing)}${progressBar}${' '.repeat(columnSpacing)}${percent}${' '.repeat(columnSpacing)}${sizeStrPadded}${' '.repeat(columnSpacing)}${task.fileName}`;
                container.appendChild(taskLine);
            });
            
            outputDiv.appendChild(container);
            scrollToBottom();
            return true;
        }


        // 停止下载 - dstop [id]
        function dstop(taskId = null) {
            if (downloadTasks.length === 0) {
                console.log("没有下载任务可停止");
                return true;
            }
            
            // 停止所有下载
            if (taskId === null) {
                let stoppedCount = 0;
                downloadTasks.forEach(task => {
                    if (task.status === 'downloading') {
                        task.status = 'paused';
                        if (task.xhr) task.xhr.abort();
                        if (task.interval) clearInterval(task.interval);
                        stoppedCount++;
                    }
                });
                console.log(`已停止 ${stoppedCount} 个下载任务`);
            } else {
                // 停止指定下载
                const task = downloadTasks.find(t => t.id === parseInt(taskId));
                if (!task) {
                    console.error(`下载任务 ${taskId} 不存在`);
                    return false;
                }
                
                if (task.status === 'downloading') {
                    task.status = 'paused';
                    if (task.xhr) task.xhr.abort();
                    if (task.interval) clearInterval(task.interval);
                    console.log(`已停止下载任务 ${taskId}: ${task.fileName}`);
                } else {
                    console.warn(`下载任务 ${taskId} 不在下载中 (当前状态: ${task.status})`);
                }
            }
            
            // 更新显示
            updateDownloadDisplay();
            return true;
        }


        // 开始下载 - dstart [id]
        function dstart(taskId = null) {
            if (downloadTasks.length === 0) {
                console.log("没有下载任务可开始");
                return true;
            }
            
            // 开始所有暂停的下载
            if (taskId === null) {
                let startedCount = 0;
                downloadTasks.forEach(task => {
                    if (task.status === 'paused') {
                        // 重新创建XHR对象
                        const xhr = new XMLHttpRequest();
                        task.xhr = xhr;
                        task.status = 'downloading';
                        
                        xhr.open('GET', task.url, true);
                        xhr.responseType = 'blob';
                        
                        // 恢复进度事件监听
                        xhr.addEventListener('progress', function(e) {
                            if (e.lengthComputable) {
                                task.totalSize = e.total;
                                task.downloadedSize = e.loaded;
                                task.progress = (e.loaded / e.total) * 100;
                                updateDownloadDisplay();
                            }
                        });
                        
                        // 恢复完成事件
                        xhr.addEventListener('load', function() {
                            if (xhr.status === 200) {
                                task.progress = 100;
                                task.downloadedSize = task.totalSize;
                                task.status = 'complete';
                                
                                // 读取下载的内容
                                const reader = new FileReader();
                                reader.onload = function() {
                                    // 将内容保存到文件系统
                                    const savePathParts = task.savePath.split('/');
                                    const fileNamePart = savePathParts.pop();
                                    const dirPath = savePathParts.join('/') || '.';
                                    const dirInfo = getNodeByPath(dirPath);
                                    
                                    if (dirInfo && !dirInfo.isRoot && dirInfo.node.type === 'directory') {
                                        dirInfo.node.children[fileNamePart] = {
                                            name: fileNamePart,
                                            type: 'file',
                                            content: reader.result,
                                            size: task.totalSize,
                                            downloaded: true
                                        };
                                    }
                                    
                                    infoLog(`下载完成: ${task.fileName} (${formatFileSize(task.totalSize)})`);
                                };
                                reader.readAsText(xhr.response);
                            } else {
                                task.status = 'failed';
                                console.error(`下载失败: 服务器返回状态码 ${xhr.status}`);
                            }
                            
                            clearInterval(task.interval);
                            updateDownloadDisplay();
                        });
                        
                        // 恢复错误事件
                        xhr.addEventListener('error', function() {
                            task.status = 'failed';
                            clearInterval(task.interval);
                            console.error(`下载失败: 网络错误`);
                            updateDownloadDisplay();
                        });
                        
                        // 恢复abort事件
                        xhr.addEventListener('abort', function() {
                            task.status = 'paused';
                            clearInterval(task.interval);
                            console.log(`下载已暂停: ${task.fileName}`);
                            updateDownloadDisplay();
                        });
                        
                        // 启动进度更新计时器
                        task.interval = setInterval(() => {
                            if (task.status !== 'downloading') return;
                            
                            // 如果无法计算总长度，模拟进度增加
                            if (task.totalSize === 0) {
                                task.downloadedSize += 1024 * 10;
                                task.progress = Math.min(task.progress + 0.5, 99);
                                updateDownloadDisplay();
                            }
                        }, 500);
                        
                        xhr.send();
                        startedCount++;
                    }
                });
                console.log(`已开始 ${startedCount} 个下载任务`);
            } else {
                // 开始指定下载
                const task = downloadTasks.find(t => t.id === parseInt(taskId));
                if (!task) {
                    console.error(`下载任务 ${taskId} 不存在`);
                    return false;
                }
                
                if (task.status === 'paused') {
                    // 重新创建XHR对象
                    const xhr = new XMLHttpRequest();
                    task.xhr = xhr;
                    task.status = 'downloading';
                    
                    xhr.open('GET', task.url, true);
                    xhr.responseType = 'blob';
                    
                    // 恢复进度事件监听
                    xhr.addEventListener('progress', function(e) {
                        if (e.lengthComputable) {
                            task.totalSize = e.total;
                            task.downloadedSize = e.loaded;
                            task.progress = (e.loaded / e.total) * 100;
                            updateDownloadDisplay();
                        }
                    });
                    
                    // 恢复完成事件
                    xhr.addEventListener('load', function() {
                        if (xhr.status === 200) {
                            task.progress = 100;
                            task.downloadedSize = task.totalSize;
                            task.status = 'complete';
                            
                            // 读取下载的内容
                            const reader = new FileReader();
                            reader.onload = function() {
                                // 将内容保存到文件系统
                                const savePathParts = task.savePath.split('/');
                                const fileNamePart = savePathParts.pop();
                                const dirPath = savePathParts.join('/') || '.';
                                const dirInfo = getNodeByPath(dirPath);
                                
                                if (dirInfo && !dirInfo.isRoot && dirInfo.node.type === 'directory') {
                                    dirInfo.node.children[fileNamePart] = {
                                        name: fileNamePart,
                                        type: 'file',
                                        content: reader.result,
                                        size: task.totalSize,
                                        downloaded: true
                                    };
                                }
                                
                                infoLog(`下载完成: ${task.fileName} (${formatFileSize(task.totalSize)})`);
                            };
                            reader.readAsText(xhr.response);
                        } else {
                            task.status = 'failed';
                            console.error(`下载失败: 服务器返回状态码 ${xhr.status}`);
                        }
                        
                        clearInterval(task.interval);
                        updateDownloadDisplay();
                    });
                    
                    // 恢复错误事件
                    xhr.addEventListener('error', function() {
                        task.status = 'failed';
                        clearInterval(task.interval);
                        console.error(`下载失败: 网络错误`);
                        updateDownloadDisplay();
                    });
                    
                    // 恢复abort事件
                    xhr.addEventListener('abort', function() {
                        task.status = 'paused';
                        clearInterval(task.interval);
                        console.log(`下载已暂停: ${task.fileName}`);
                        updateDownloadDisplay();
                    });
                    
                    // 启动进度更新计时器
                    task.interval = setInterval(() => {
                        if (task.status !== 'downloading') return;
                        
                        // 如果无法计算总长度，模拟进度增加
                        if (task.totalSize === 0) {
                            task.downloadedSize += 1024 * 10;
                            task.progress = Math.min(task.progress + 0.5, 99);
                            updateDownloadDisplay();
                        }
                    }, 500);
                    
                    xhr.send();
                    console.log(`已开始下载任务 ${taskId}: ${task.fileName}`);
                } else if (task.status === 'downloading') {
                    console.warn(`下载任务 ${taskId} 已经在下载中`);
                } else {
                    console.warn(`下载任务 ${taskId} 无法开始 (当前状态: ${task.status})`);
                }
            }
            
            // 更新显示
            updateDownloadDisplay();
            return true;
        }


        // 删除下载任务 - drm [id]
        function drm(taskId = null) {
            if (downloadTasks.length === 0) {
                console.log("没有下载任务可删除");
                return true;
            }
            
            // 删除所有下载任务
            if (taskId === null) {
                // 清除所有XHR和定时器
                downloadTasks.forEach(task => {
                    if (task.xhr) task.xhr.abort();
                    if (task.interval) clearInterval(task.interval);
                });
                
                const count = downloadTasks.length;
                downloadTasks = [];
                console.log(`已删除所有 ${count} 个下载任务`);
            } else {
                // 删除指定下载任务
                const taskIndex = downloadTasks.findIndex(t => t.id === parseInt(taskId));
                if (taskIndex === -1) {
                    console.error(`下载任务 ${taskId} 不存在`);
                    return false;
                }
                
                // 清除XHR和定时器
                if (downloadTasks[taskIndex].xhr) {
                    downloadTasks[taskIndex].xhr.abort();
                }
                if (downloadTasks[taskIndex].interval) {
                    clearInterval(downloadTasks[taskIndex].interval);
                }
                
                const task = downloadTasks.splice(taskIndex, 1)[0];
                console.log(`已删除下载任务 ${taskId}: ${task.fileName}`);
            }
            
            // 更新显示
            updateDownloadDisplay();
            return true;
        }


        // 清除已完成的下载任务 - dlsc
        function dlsc() {
            if (downloadTasks.length === 0) {
                console.log("没有下载任务");
                return true;
            }
            
            // 保存非完成状态的任务
            const incompleteTasks = [];
            let removedCount = 0;
            
            downloadTasks.forEach(task => {
                if (task.status === 'complete') {
                    // 清除定时器
                    if (task.interval) clearInterval(task.interval);
                    removedCount++;
                } else {
                    incompleteTasks.push(task);
                }
            });
            
            downloadTasks = incompleteTasks;
            console.log(`已清除 ${removedCount} 个已完成的下载任务`);
            
            // 更新显示
            updateDownloadDisplay();
            return true;
        }


        // 移动文件/目录
        function mv(sourcePath, destPath) {
            // 获取源节点信息
            const sourceInfo = getNodeByPath(sourcePath);
            if (!sourceInfo || sourceInfo.isRoot) {
                console.error(`源路径 ${sourcePath} 不存在`);
                return false;
            }
            
            // 获取目标目录信息
            const destInfo = getNodeByPath(destPath);
            
            // 如果目标路径不存在，尝试解析为目录+文件名
            let destDirInfo, destName;
            if (!destInfo) {
                // 拆分目标路径为目录和文件名
                const destParts = destPath.split('/');
                destName = destParts.pop();
                const destDirPath = destParts.join('/') || '.';
                destDirInfo = getNodeByPath(destDirPath);
                
                if (!destDirInfo || destDirInfo.isRoot || destDirInfo.node.type !== 'directory') {
                    console.error(`目标目录 ${destDirPath} 不存在`);
                    return false;
                }
            } else {
                // 如果目标是目录，使用源文件名
                if (destInfo.node.type === 'directory') {
                    destDirInfo = destInfo;
                    destName = sourceInfo.node.name;
                } else {
                    // 如果目标是文件，使用其路径
                    const destParts = destPath.split('/');
                    destName = destParts.pop();
                    const destDirPath = destParts.join('/') || '.';
                    destDirInfo = getNodeByPath(destDirPath);
                    
                    if (!destDirInfo || destDirInfo.isRoot || destDirInfo.node.type !== 'directory') {
                        console.error(`目标目录 ${destDirPath} 不存在`);
                        return false;
                    }
                }
            }
            
            // 检查目标位置是否已存在同名文件/目录
            if (destDirInfo.node.children[destName]) {
                console.error(`目标位置已存在 ${destName}`);
                return false;
            }
            
            // 获取源文件的父目录 - 修复：处理根目录情况
            const sourcePathParts = resolvePath(sourcePath).path;
            const sourceName = sourcePathParts[sourcePathParts.length - 1];
            
            // 特殊处理根目录下的文件/目录
            let sourceParentInfo, sourceParentNode;
            if (sourcePathParts.length === 2) {  // 根目录下的项目路径长度为2: ['/', 'item']
                sourceParentNode = disks[currentDisk].filesystem;
                sourceParentInfo = { node: sourceParentNode };
            } else {
                const sourceParentPath = sourcePathParts.slice(0, -1).join('/') || '.';
                sourceParentInfo = getNodeByPath(sourceParentPath);
                
                if (!sourceParentInfo || sourceParentInfo.isRoot || sourceParentInfo.node.type !== 'directory') {
                    console.error("无法找到源文件的父目录");
                    return false;
                }
                sourceParentNode = sourceParentInfo.node;
            }
            
            // 执行移动操作（深度复制）
            function deepCopyNode(node, newName) {
                const copy = JSON.parse(JSON.stringify(node));
                copy.name = newName;
                return copy;
            }
            
            destDirInfo.node.children[destName] = deepCopyNode(sourceInfo.node, destName);
            
            // 删除原节点
            delete sourceParentNode.children[sourceName];
            
            // 统计移动的项目数量
            let itemCount = 0;
            function countItems(node) {
                itemCount++;
                if (node.type === 'directory') {
                    Object.values(node.children).forEach(child => countItems(child));
                }
            }
            countItems(sourceInfo.node);
            
            console.log(`已将 ${sourcePath} 移动到 ${destPath}，共移动 ${itemCount} 个项目`);
            return true;
        }


        // 复制文件/目录 - cp path1 path2
        function cp(sourcePath, destPath) {
            // 获取源节点信息
            const sourceInfo = getNodeByPath(sourcePath);
            if (!sourceInfo || sourceInfo.isRoot) {
                console.error(`源路径 ${sourcePath} 不存在`);
                return false;
            }
            
            // 获取目标目录信息
            const destInfo = getNodeByPath(destPath);
            
            // 如果目标路径不存在，尝试解析为目录+文件名
            let destDirInfo, destName;
            if (!destInfo) {
                // 拆分目标路径为目录和文件名
                const destParts = destPath.split('/');
                destName = destParts.pop();
                const destDirPath = destParts.join('/') || '.';
                destDirInfo = getNodeByPath(destDirPath);
                
                if (!destDirInfo || destDirInfo.isRoot || destDirInfo.node.type !== 'directory') {
                    console.error(`目标目录 ${destDirPath} 不存在`);
                    return false;
                }
            } else {
                // 如果目标是目录，使用源文件名
                if (destInfo.node.type === 'directory') {
                    destDirInfo = destInfo;
                    destName = sourceInfo.node.name;
                } else {
                    // 如果目标是文件，使用其路径
                    const destParts = destPath.split('/');
                    destName = destParts.pop();
                    const destDirPath = destParts.join('/') || '.';
                    destDirInfo = getNodeByPath(destDirPath);
                    
                    if (!destDirInfo || destDirInfo.isRoot || destDirInfo.node.type !== 'directory') {
                        console.error(`目标目录 ${destDirPath} 不存在`);
                        return false;
                    }
                }
            }
            
            // 检查目标位置是否已存在同名文件/目录
            if (destDirInfo.node.children[destName]) {
                console.error(`目标位置已存在 ${destName}，无法复制`);
                return false;
            }
            
            // 执行复制操作（深度复制）
            function deepCopyNode(node, newName) {
                const copy = JSON.parse(JSON.stringify(node));
                copy.name = newName;
                return copy;
            }
            
            destDirInfo.node.children[destName] = deepCopyNode(sourceInfo.node, destName);
            
            // 统计复制的项目数量
            let itemCount = 0;
            function countItems(node) {
                itemCount++;
                if (node.type === 'directory') {
                    Object.values(node.children).forEach(child => countItems(child));
                }
            }
            countItems(sourceInfo.node);
            
            console.log(`已将 ${sourcePath} 复制到 ${destPath}，共复制 ${itemCount} 个项目`);
            return true;
        }


        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }


        // 命令管理相关命令实现
        function registerCommand(args) {
            if (args.length < 2) {
                console.error("使用方法: registercmd <命令名> <JavaScript函数> [描述]");
                console.error("示例: registercmd hello 'function(args){console.log(\"Hello World!\")}' '显示问候语'");
                return false;
            }
            
            const cmdName = args[0];
            const functionCode = args[1];
            const description = args.slice(2).join(' ') || '';
            
            try {
                // 创建函数
                const func = new Function('return ' + functionCode)();
                
                // 注册命令
                return CommandManager.register(cmdName, func, description);
            } catch (error) {
                console.error(`注册命令失败: 函数解析错误 - ${error.message}`);
                return false;
            }
        }
        
        function unregisterCommand(args) {
            if (args.length !== 1) {
                console.error("使用方法: unregistercmd <命令名>");
                return false;
            }
            
            return CommandManager.unregister(args[0]);
        }
        
        function listCommands(args) {
            // 默认为只显示自定义命令
            let showSystem = false;
            let showCustom = true;
            
            if (args.length > 0 && args[0] === '-a') {
                showSystem = true;
            }
            
            CommandManager.list(showSystem, showCustom);
            return true;
        }


        // 帮助命令 - 新增自定义命令相关说明
        function showHelp() {
            console.log("=== BlockOS 命令帮助 ===");
            console.log("文件类型说明:");
            console.log("  .js - 程序文件（主要执行文件）");
            console.log("  .r  - 脚本文件（辅助脚本）");
            
            console.log("\n文件系统命令:");
            console.log("  ls                - 查看当前挂载磁盘的当前目录内容");
            console.log("  tree              - 显示当前挂载磁盘的完整树形结构");
            console.log("  cd <路径>         - 切换到当前磁盘中的指定目录");
            console.log("  mkdir <目录名>    - 创建目录");
            console.log("  touch <文件名>    - 创建文件");
            console.log("  rm <路径>         - 删除文件或目录");
            console.log("  cat <文件名>      - 查看文件内容");
            console.log("  mv <源路径> <目标路径> - 移动文件或目录（包括所有子内容）");
            console.log("  cp <源路径> <目标路径> - 复制文件或目录（包括所有子内容）");
            
            console.log("\n导入导出命令:");
            console.log("  ipj               - 导入文件夹到当前目录");
            console.log("  ife               - 导入文件到当前目录");
            console.log("  odk [文件名]      - 导出当前磁盘为.dk文件");
            
            console.log("\n下载管理:");
            console.log("  dd <url> [保存路径] - 下载文件，url为必填，保存路径可选");
            console.log("  dlist             - 查看所有下载任务及进度");
            console.log("  dstop [任务ID]     - 停止指定下载任务，无ID则停止所有");
            console.log("  dstart [任务ID]    - 开始指定下载任务，无ID则开始所有");
            console.log("  drm [任务ID]       - 删除指定下载任务，无ID则删除所有");
            console.log("  dlsc              - 清除所有已完成的下载任务");
            
            console.log("\n磁盘管理:");
            console.log("  lsd               - 查看所有已挂载的磁盘");
            console.log("  ld <磁盘名>        - 切换到指定磁盘");
            console.log("  mount             - 挂载磁盘文件(.dk)");
            console.log("  unmount <磁盘名>   - 卸载磁盘");
            
            console.log("\n程序运行:");
            console.log("  run <文件名>      - 运行.js程序或.r脚本");
            console.log("  js <代码>            - 直接执行JavaScript代码，例如: js console.log('hello')");
            
            console.log("\n命令管理:");
            console.log("  registercmd <命令名> <函数> [描述] - 注册自定义命令");
            console.log("  unregistercmd <命令名> - 注销自定义命令");
            console.log("  listcmds [-a]     - 列出所有命令，-a参数显示系统命令");
            
            console.log("\n其他命令:");
            console.log("  clear             - 清空屏幕");
            console.log("  help              - 显示此帮助信息");
        }


        function clearScreen() {
            outputDiv.innerHTML = '';
            console.log("屏幕已清除");
            return true;
        }


        // 挂载磁盘
        function mount() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dk';
            
            input.onchange = async function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                if (!file.name.endsWith('.dk')) {
                    console.error("请导入 .dk 格式的磁盘文件");
                    return;
                }
                
                let baseName = 'disk';
                let diskName = baseName;
                let counter = 1;
                
                while (disks[diskName]) {
                    diskName = `${baseName}${counter}`;
                    counter++;
                }
                
                try {
                    const zip = await JSZip.loadAsync(file);
                    const fsFile = zip.file('filesystem.json');
                    
                    if (!fsFile) {
                        console.error("无效的磁盘文件");
                        return;
                    }
                    
                    const fsContent = await fsFile.async('string');
                    const filesystem = JSON.parse(fsContent);
                    
                    disks[diskName] = {
                        name: diskName,
                        filesystem: filesystem
                    };
                    
                    console.log(`磁盘 ${diskName} 挂载成功`);
                    lsd();
                } catch (error) {
                    console.error(`挂载失败: ${error.message}`);
                }
            };
            
            input.click();
        }


        // 卸载磁盘
        function unmount(diskName) {
            if (diskName === 'disk') {
                console.error("系统磁盘不能卸载");
                return false;
            }
            
            if (!disks[diskName]) {
                console.error(`磁盘 ${diskName} 不存在`);
                return false;
            }
            
            if (diskName === currentDisk) {
                currentDisk = 'disk';
                currentPath = ['/'];
                updateCurrentPath();
                console.log(`已自动切换到系统磁盘`);
            }
            
            delete disks[diskName];
            console.log(`磁盘 ${diskName} 已卸载`);
            return true;
        }


        // 命令执行器 - 添加自定义命令支持
        function executeCommand(command) {
            const p = document.createElement('p');
            p.className = 'log';
            p.textContent = `> ${command}`; // 命令行前缀
            outputDiv.appendChild(p);
            
            const parts = command.trim().split(/\s+/).filter(part => part !== '');
            if (parts.length === 0) return;


            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            // 先尝试执行自定义命令
            if (CommandManager.execute(cmd, args)) {
                return;
            }


            // 执行系统命令
            switch (cmd) {
                case 'ls':
                    ls(args.length > 0 ? args[0] : '.');
                    break;
                    
                case 'tree':
                    tree(args.length > 0 ? args[0] : '.');
                    break;
                    
                case 'lsd':
                    lsd();
                    break;
                    
                case 'cd':
                    cd(args.length > 0 ? args[0] : '/');
                    break;
                    
                case 'mkdir':
                    args.length === 1 ? mkdir(args[0]) : console.error("使用方法: mkdir <目录名>");
                    break;
                    
                case 'touch':
                    args.length === 1 ? touch(args[0]) : console.error("使用方法: touch <文件名>");
                    break;
                    
                case 'rm':
                    args.length === 1 ? rm(args[0]) : console.error("使用方法: rm <路径>");
                    break;
                    
                case 'cat':
                    args.length === 1 ? cat(args[0]) : console.error("使用方法: cat <文件名>");
                    break;
                    
                case 'ld':
                    args.length === 1 ? switchDisk(args[0]) : console.error("使用方法: ld <磁盘名>");
                    break;
                    
                case 'mount':
                    mount();
                    break;
                    
                case 'unmount':
                    args.length === 1 ? unmount(args[0]) : console.error("使用方法: unmount <磁盘名>");
                    break;
                    
                case 'ipj':
                    importFolder();
                    break;
                    
                case 'ife':
                    importFile();
                    break;
                    
                case 'odk':
                    exportAsDk(args.length > 0 ? args[0] : null);
                    break;
                    
                case 'run':
                    args.length === 1 ? run(args[0]) : console.error("使用方法: run <文件名>");
                    break;
                    
                // 新增：js命令处理
                case 'js':
                    if (args.length > 0) {
                        // 合并所有参数作为要执行的JavaScript代码
                        const jsCode = args.join(' ');
                        executeJavaScript(jsCode);
                    } else {
                        console.error("使用方法: js <JavaScript代码>，例如: js console.log('hello')");
                    }
                    break;
                    
                case 'dd':
                    if (args.length >= 1) {
                        dd(args[0], args.length >= 2 ? args[1] : null);
                    } else {
                        console.error("使用方法: dd <url> [保存路径] (url为必填参数)");
                    }
                    break;
                    
                case 'dlist':
                    dlist();
                    break;
                    
                case 'dstop':
                    dstop(args.length >= 1 ? args[0] : null);
                    break;
                    
                case 'dstart':
                    dstart(args.length >= 1 ? args[0] : null);
                    break;
                    
                case 'drm':
                    drm(args.length >= 1 ? args[0] : null);
                    break;
                    
                case 'dlsc':
                    dlsc();
                    break;
                    
                case 'mv':
                    if (args.length === 2) {
                        mv(args[0], args[1]);
                    } else {
                        console.error("使用方法: mv <源路径> <目标路径>");
                    }
                    break;
                    
                case 'cp':
                    if (args.length === 2) {
                        cp(args[0], args[1]);
                    } else {
                        console.error("使用方法: cp <源路径> <目标路径>");
                    }
                    break;
                    
                case 'clear':
                    clearScreen();
                    break;
                    
                case 'help':
                    showHelp();
                    break;
                    
                // 命令管理相关命令
                case 'registercmd':
                    registerCommand(args);
                    break;
                    
                case 'unregistercmd':
                    unregisterCommand(args);
                    break;
                    
                case 'listcmds':
                    listCommands(args);
                    break;
                    
                default:
                    console.error(`未知命令: ${cmd}，输入 help 查看可用命令`);
            }
        }


        // 事件监听
        commandInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                const command = commandInput.value.trim();
                if (command) executeCommand(command);
                commandInput.value = '';
            }
        });

        // 允许使用鼠标滚轮滚动终端内容
        terminalDiv.addEventListener('wheel', function(e) {
            // 自然滚动行为，不需要额外处理
        });


        // 初始化
        updateCurrentPath();
        commandInput.focus();
        console.log("欢迎使用 BlockOS");
        console.log("最新更新:");
        console.log("  - 添加了自定义命令系统");
        console.log("  - 可以注册、注销和管理自定义命令");
        console.log("  - 系统命令受到保护，无法被覆盖或删除");
        console.log("  - 新增 registercmd, unregistercmd, listcmds 命令");
        console.log("输入 help 查看完整命令列表");
        console.log("示例: 注册一个简单的问候命令:");
    </script>
</body>
</html>
